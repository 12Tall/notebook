# 创建并运行Julia 项目  

## 切换REPL模式  

- julia： 默认模式，按`backspace`切换   
- shell： 按`;`  
- help： `?`，可以用来查询一些生僻字符    
- pkg：`]`，用于管理包和项目     

## 创建项目  

将REPL 切换至pkg 模式下，运行`generate {project_name}[.jl]` 即可创建项目（包）。  
```shell-session
(@v1.7) pkg> generate prj
  Generating  project prj:
    prj\Project.toml  # 包信息，包括作者、版本等信息
    prj\src/prj.jl    # 源码，包括模块的定义  
```

## 引用包  
切换到项目下，然后在pkg 模式下执行`active .`，即可切换包管理器所在目录。  
```shell-session
(@v1.7) pkg> activate .
  Activating project at `D:\code\notebook\Julia\prj`

(prj) pkg>  # 按backspace 切换回julia  
julia> prj.greet()
Hello World!
julia> 
```

### 全局安装  
如果需要在全局引用，则需要将项目上传至GitHub，然后在包管理中安装此项目：  
```shell-session
(prj) pkg> activate
  Activating project at `C:\Users\fbouy\.julia\environments\v1.7`

(@v1.7) pkg> add git@github.com:xxx/xxx.git
```

所以可以猜测，Julia 项目分全局包和局部包，局部包的路径应在当前项目下。  

### import 与using  
- import 默认导入包内的全部变量，除非显式指定  
- using 只导入模块中export 的变量  

### 模块文件路径  
- 全局变量需要通过修改`LOAD_PATH`或者`JULIA_LOAD_PATH`来扩展模块路径  
- 正常用我们可以使用`include()` 来拼接代码  

```julia
include("mycode.jl")  # 相当于把代码拷贝到这个位置  
```

### 使用Revise  
import 模块后如果有更新需要重新加载模块，而`Revise`模块可以帮我们自动化完成这个工作。  
```shell-session
(prj) pkg> add Revise
   Resolving package versions...
  No Changes to `D:\code\notebook\Julia\prj\Project.toml`
  No Changes to `D:\code\notebook\Julia\prj\Manifest.toml`
Precompiling project...
  ✓ prj
  1 dependency successfully precompiled in 0 seconds (9 already precompiled)
  1 dependency precompiled but a different version is currently loaded. Restart julia to access the new version

(prj) pkg> 

julia> using Revise  # 之后我们修改prj 模块的源码之后都会自动更新到REPL 会话中  
julia> using prj
julia> 
```  

### 从文件中启动  
创建`main.jl` 文件  
```julia
# main.jl
using Revise  

module mmm  # 相当于把子文件里的源码拷贝成一个新的模块mmm
    include("src/prj.jl")    
#=  # src/prj.jl #
    
    module prj
        include("submd.jl")  # 嵌套引入子模块  

        greet() = print("Hello World!")
        y()="y"
    end # module
=#
end

mmm.prj.greet()
```

也可以将下面代码添加至`{install_folder}/etc/julia/startup.jl`，用于自动启动Revise  
```julia
using Revise
println("===== Revise loaded =====")
```  

## 生成二进制可执行文件  

```shell-session  
julia> using Pkg  # 安装编译工具模块  

julia> Pkg.add("PackageCompiler")
    Updating registry at `C:\Users\fbouy\.julia\registries\General.toml`
   Resolving package versions...
  No Changes to `C:\Users\fbouy\.julia\environments\v1.7\Project.toml`
  No Changes to `C:\Users\fbouy\.julia\environments\v1.7\Manifest.toml`

julia> Pkg.generate("myapp")  # 创建项目，如果项目已存在应该是需要切换到上层目录  

给app/src/app.jl 文件添加julia_main() 函数，作为程序入口  
如果有依赖项的话需要先切换至项目根目录安装依赖项  

shell> cd myapp\\
(@v1.7) pkg> add Gtk 
shell> cd ..\\

julia> using PackageCompiler    


julia> create_app("myapp", "out", incremental=true)  # （增量）编译到out 文件夹  
sysimage_build_args=`-mwindows` 可以传入更多参数
然后`稍等`六七分钟就能生成可执行文件了
```

下面是简单的入口函数：  

```julia
module myapp

greet() = print("Hello World!!!")

function julia_main()::Cint
    # do something based on ARGS?
    greet()
    return 0 # if things finished successfully
  end

end # module
```

> `out/bin` 包含可执行文件，里面也有一个`julia.exe`，进去默认就能使用`myapp` 模块。

## GUI 程序  
因为Julia 支持GTK，所以计划使用GTK 实现，需要预装msys2 和glade，用于设计界面。  
Gtk.jl 在REPL 和文件模式下的工作方式也略有不同  
```shell-session
julia> LazyArtifacts.artifact"mingw-w64"
"C:\\Users\\fbouy\\.julia\\artifacts\\fdff308295487f361ef6e8dc2d27f5abe8a6eee9"
根据PackageCompiler.jl 源码可知，可以通过JULIA_CC环境变量指定编译器和参数

julia> EN
ENDIAN_BOM ENV

julia> ENV["JULIA_CC"]="C:\\Users\\fbouy\\.julia\\artifacts\\fdff308295487f361ef6e8dc2d27f5abe8a6eee9\\mingw64\\bin\\gcc.exe -mwindows"
"C:\\Users\\fbouy\\.julia\\artifacts\\fdff308295487f361ef6e8dc2d27f5abe8a6eee9\\mingw64\\bin\\gcc.exe -mwindows"
也可以指定自己的编译器路径
```